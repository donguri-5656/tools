<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ğŸ¿ï¸</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            background: #d0f0ff;
            font-family: sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            position: relative;
        }
        #wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
            padding: 10px;
            box-sizing: border-box;
        }
        canvas {
            background: #ffffff;
            border: 4px solid #a0e0ff;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            margin: 5px;
        }
        #game-container {
            position: relative;
        }
        #tetris {
            top: 0;
            left: 0;
            z-index: 1;
        }
        #ui {
            display: grid;
            grid-template-areas:
                "rotL hard rotR"
                "left . right"
                ". down hold";
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
            padding: 0 10px;
            width: 100%;
            max-width: 400px;
        }
        .btn {
            padding: 15px 0;
            font-size: 18px;
            border: none;
            border-radius: 10px;
            background: #a0e0ff;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            width: 100%;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }
        .btn-left { grid-area: left; }
        .btn-right { grid-area: right; }
        .btn-rotate-left { grid-area: rotL; }
        .btn-rotate-right { grid-area: rotR; }
        .btn-down { grid-area: down; }
        .btn-hard-drop { grid-area: hard; }
        .btn-hold { grid-area: hold; }

        .info {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 2px;
            align-items: flex-start;
        }
        .info > div {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #score {
            margin: 2px;
            font-size: 20px;
            font-weight: bold;
        }
        /* Modal Overlay */
        #overlay, #ranking-overlay, #game-over-overlay, #pause-overlay, #difficulty-selection-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        /* Modal Content */
        #mode-selection-modal, #ranking-modal, #game-over-modal, #pause-modal, #difficulty-selection-modal {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 90%;
            width: 350px;
        }

        #mode-selection-modal h2, #ranking-modal h2, #game-over-modal h2, #pause-modal h2, #difficulty-selection-modal h2 {
            margin-top: 0;
            color: #333;
        }
        #game-over-modal p {
            font-size: 1.2em;
            margin: 10px 0;
        }


        #mode-selection-modal button, #ranking-modal button, #game-over-modal button, #pause-modal button, #difficulty-selection-modal button {
            display: block;
            width: 80%;
            padding: 15px;
            margin: 15px auto;
            font-size: 20px;
            border: none;
            border-radius: 8px;
            background: #a0e0ff;
            box-shadow: 0 3px 5px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: background 0.3s ease;
        }

        #mode-selection-modal button:hover, #ranking-modal button:hover, #game-over-modal button:hover, #pause-modal button:hover, #difficulty-selection-modal button:hover {
            background: #80cfff;
        }
        /* Pause Button - ç”»é¢å³ä¸Šã«å›ºå®š */
        #pause-button {
            position: fixed;
            top: 50px;
            right: 10px;
            width: 80px;
            height: 40px;
            padding: 0;
            font-size: 16px;
            background: #a0e0ff;
            border: 2px solid #66b0d0;
            border-radius: 8px;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #pause-button:hover {
            background: #80cfff;
        }
    </style>
</head>
<body>
    <div id="score">ã‚¹ã‚³ã‚¢: 0</div>

    <button id="pause-button" onclick="togglePause()" style="display: none;">ä¸€æ™‚åœæ­¢</button>

    <div id="wrapper">
        <div class="info">
            <div>
                <p>NEXT</p>
                <canvas id="next" width="80" height="240"></canvas>
            </div>
            <div id="game-container">
                <canvas id="tetris" width="200" height="400"></canvas>
            </div>
            <div>
                <p>HOLD</p>
                <canvas id="hold" width="80" height="80"></canvas>
            </div>
        </div>
        <div id="ui">
            <button class="btn btn-rotate-left" onclick="playerRotate(false)">å·¦å›è»¢</button>
            <button class="btn btn-hard-drop" onclick="hardDrop()">â†‘</button>
            <button class="btn btn-rotate-right" onclick="playerRotate(true)">å³å›è»¢</button>
            <button class="btn btn-left" onclick="playerMove(-1)">â†</button>
            <button class="btn btn-right" onclick="playerMove(1)">â†’</button>
            <button class="btn btn-down" onmousedown="startSoftDrop()" onmouseup="stopSoftDrop()" onmouseleave="stopSoftDrop()" ontouchstart="startSoftDrop()" ontouchend="stopSoftDrop()">â†“</button>
            <button class="btn btn-hold" onclick="holdPiece()">HOLD</button>
        </div>
    </div>

    <div id="overlay">
        <div id="mode-selection-modal">
            <h2>æ“ä½œãƒ¢ãƒ¼ãƒ‰é¸æŠ</h2>
            <button id="btn-mode-button">ãƒœã‚¿ãƒ³æ“ä½œ</button>
            <button id="btn-mode-gesture">ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼æ“ä½œ</button>
        </div>
    </div>

    <div id="difficulty-selection-overlay" style="display: none;">
        <div id="difficulty-selection-modal">
            <h2>é›£æ˜“åº¦é¸æŠ</h2>
            <button id="btn-difficulty-easy" data-difficulty="easy">ã‹ã‚“ãŸã‚“</button>
            <button id="btn-difficulty-normal" data-difficulty="normal">ãµã¤ã†</button>
            <button id="btn-difficulty-hard" data-difficulty="hard">ã‚€ãšã‹ã—ã„</button>
            <button id="btn-back-to-mode-selection">æˆ»ã‚‹</button>
        </div>
    </div>

    <div id="game-over-overlay" style="display: none;">
        <div id="game-over-modal">
            <h2>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼</h2>
            <p id="final-score-display"></p>
            <p id="lines-cleared-display"></p>
            <p id="max-combo-display"></p>
            <button onclick="hideGameOverModalAndShowMenu()">ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
        </div>
    </div>

    <div id="pause-overlay" style="display: none;">
        <div id="pause-modal">
            <h2>ä¸€æ™‚åœæ­¢ä¸­</h2>
            <button onclick="resumeGame()">ã‚²ãƒ¼ãƒ å†é–‹</button>
            <button onclick="endGame()">ã‚²ãƒ¼ãƒ çµ‚äº†</button>
        </div>
    </div>

    <script>

        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        context.scale(20, 20); // 1ãƒã‚¹20x20ãƒ”ã‚¯ã‚»ãƒ«

        const nextCanvas = document.getElementById('next');
        const nextCtx = nextCanvas.getContext('2d');
        nextCtx.scale(20, 20); // 1ãƒã‚¹20x20ãƒ”ã‚¯ã‚»ãƒ«

        const holdCanvas = document.getElementById('hold');
        const holdCtx = holdCanvas.getContext('2d');
        holdCtx.scale(20, 20); // 1ãƒã‚¹20x20ãƒ”ã‚¯ã‚»ãƒ«

        let score = 0;
        let linesCleared = 0;
        let combo = -1;
        let maxCombo = 0;
        let currentControlMode = 'button'; // 'button', 'gesture'
        let currentDifficulty = 'normal'; // 'easy', 'normal', 'hard'
        let perfectClearBonus = false; // Perfect Clearåˆ¤å®šç”¨ãƒ•ãƒ©ã‚°

     document.addEventListener('dblclick', function(e) {
    e.preventDefault();
  }, { passive: false });


        const scoreElem = document.getElementById('score');
        const pauseButton = document.getElementById('pause-button');
        const pauseOverlay = document.getElementById('pause-overlay');

        const colors = {
            'I': '#66CCFF', // æ°´è‰²
            'O': '#FFCC66', // ã‚ªãƒ¬ãƒ³ã‚¸ãŒã‹ã£ãŸé»„è‰²
            'T': '#CC66FF', // ç´«
            'S': '#66FF66', // ç·‘
            'Z': '#FF6666', // èµ¤
            'J': '#6666FF', // é’
            'L': '#FF9966', // ã‚ªãƒ¬ãƒ³ã‚¸
            'ghost': 'rgba(128, 128, 128, 0.4)', // ã‚´ãƒ¼ã‚¹ãƒˆãƒ”ãƒ¼ã‚¹ (åŠé€æ˜ã‚°ãƒ¬ãƒ¼ã€èƒŒæ™¯è‰²ã«é¦´æŸ“ã‚€ã‚ˆã†ã«èª¿æ•´)
            'border': '#a0e0ff', // borderè‰²
        };

        function createMatrix(w, h) {
            const matrix = [];
            while (h--) matrix.push(new Array(w).fill(0));
            return matrix;
        }

        function drawMatrix(matrix, offset, ctx, type, alpha = 1) {
            const baseColor = (type === 'ghost') ? colors['ghost'] : colors[type];

            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = baseColor;
                        ctx.globalAlpha = alpha;
                        ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                        ctx.strokeStyle = colors['border'];
                        ctx.lineWidth = 0.03;
                        ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
                        ctx.globalAlpha = 1;
                    }
                });
            });
        }

        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        arena[y + player.pos.y][x + player.pos.x] = player.type;
                    }
                });
            });
        }

        function collide(arena, player) {
            const [m, o] = [player.matrix, player.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                        ((arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0 ||
                        y + o.y >= arena.length ||
                        x + o.x < 0 || x + o.x >= arena[0].length)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function rotate(matrix, rightRotate = true) {
            const newMatrix = createMatrix(matrix.length, matrix[0].length);
            if (rightRotate) {
                for (let y = 0; y < matrix.length; y++) {
                    for (let x = 0; x < matrix[y].length; x++) {
                        newMatrix[x][matrix.length - 1 - y] = matrix[y][x];
                    }
                }
            } else { // Counter-clockwise rotation
                for (let y = 0; y < matrix.length; y++) {
                    for (let x = 0; x < matrix[y].length; x++) {
                        newMatrix[matrix[y].length - 1 - x][y] = matrix[y][x];
                    }
                }
            }
            return newMatrix;
        }

        // --- SRS (Super Rotation System) Kick Data ---
        const SRS_KICKS_JLSZT = [
            [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],     // 0 >> R (current state 0, next state R)
            [[0,0], [1,0], [1,1], [0,-2], [1,-2]],       // R >> 2
            [[0,0], [1,0], [1,-1], [0,2], [1,2]],        // 2 >> L
            [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]]     // L >> 0
        ];

        const SRS_KICKS_I = [
            [[0,0], [-2,0], [1,0], [-2,1], [1,-2]],     // 0 >> R (current state 0, next state R)
            [[0,0], [-1,0], [2,0], [-1,-2], [2,1]],     // R >> 2
            [[0,0], [2,0], [-1,0], [2,-1], [-1,2]],     // 2 >> L
            [[0,0], [1,0], [-2,0], [1,2], [-2,-1]]      // L >> 0
        ];
        
        const SRS_KICKS_JLSZT_CCW = [
            [[0,0], [1,0], [1,-1], [0,2], [1,2]],     // 0 >> L (corresponds to R >> 0 negated x)
            [[0,0], [1,0], [1,1], [0,-2], [1,-2]],    // L >> 2 (corresponds to 2 >> R negated x)
            [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],  // 2 >> R (corresponds to 0 >> R negated x)
            [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]]  // R >> 0 (corresponds to L >> 0 negated x)
        ];

        const SRS_KICKS_I_CCW = [
            [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],  // 0 >> L (corresponds to R >> 0 negated x)
            [[0,0], [1,0], [-2,0], [1,-2], [-2,1]],  // L >> 2 (corresponds to 2 >> R negated x)
            [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],  // 2 >> R (corresponds to 0 >> R negated x)
            [[0,0], [-1,0], [2,0], [-1,2], [-2,-1]]    // R >> 0 (corresponds to L >> 0 negated x)
        ];

        function checkTSpin(originalPos, newPos, currentMatrix, arena) {
            if (player.type !== 'T') return false;

            // TãƒŸãƒã®å›è»¢ä¸­å¿ƒã‹ã‚‰ã®ç›¸å¯¾åº§æ¨™ã§ã‚³ãƒ¼ãƒŠãƒ¼ã‚’å®šç¾©
            // TãƒŸãƒã®å›è»¢ä¸­å¿ƒã¯ matrix[1][1]
            // å„å›è»¢çŠ¶æ…‹ã§ã®TãƒŸãƒã®å½¢çŠ¶ã¨ã‚³ãƒ¼ãƒŠãƒ¼ã®å®šç¾©ã«ã‚ˆã‚‹
            // ä¸€èˆ¬çš„ã«ã¯ã€3x3ã®TãƒŸãƒã®ã‚³ãƒ¼ãƒŠãƒ¼ã¯ (0,0), (2,0), (0,2), (2,2)
            // TãƒŸãƒã®å›è»¢ä¸­å¿ƒã®ã‚»ãƒ«ãŒ (player.pos.x + 1, player.pos.y + 1) ã«ã‚ã‚‹ã¨ä»®å®š

            const cornersToCheck = [
                {dx: 0, dy: 0}, // å·¦ä¸Š
                {dx: 2, dy: 0}, // å³ä¸Š
                {dx: 0, dy: 2}, // å·¦ä¸‹
                {dx: 2, dy: 2}  // å³ä¸‹
            ];

            let blockedCorners = 0;
            for (const offset of cornersToCheck) {
                const checkX = player.pos.x + offset.dx;
                const checkY = player.pos.y + offset.dy;

                // ç›¤é¢ã®å¤–ã€ã¾ãŸã¯åŸ‹ã¾ã£ã¦ã„ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã§ã‚ã‚Œã°ãƒ–ãƒ­ãƒƒã‚¯ã¨åˆ¤å®š
                if (checkY < 0 || checkY >= arena.length || checkX < 0 || checkX >= arena[0].length || arena[checkY][checkX] !== 0) {
                    blockedCorners++;
                }
            }
            
            // T-Spinã®æ¡ä»¶: 3ã¤ã®ã‚³ãƒ¼ãƒŠãƒ¼ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ã“ã¨
            return blockedCorners >= 3;
        }


        function playerRotate(isRight = true) {
            if (isPaused) return;

            const clonedMatrix = player.matrix.map(row => [...row]);
            const originalPos = { x: player.pos.x, y: player.pos.y };
            const originalRotState = player.rotState;

            const rotated = rotate(player.matrix, isRight);
            player.matrix = rotated;

            let kicks;
            let currentKicksIndex;

            if (player.type === 'I') {
                kicks = isRight ? SRS_KICKS_I : SRS_KICKS_I_CCW;
            } else { // J, L, S, Z, T
                kicks = isRight ? SRS_KICKS_JLSZT : SRS_KICKS_JLSZT_CCW;
            }

            currentKicksIndex = originalRotState;
            
            const kickTableToUse = isRight ? kicks : kicks; 

            let rotatedSuccessfully = false;
            let finalKickOffset = {x: 0, y: 0}; 

            for (let i = 0; i < kickTableToUse[currentKicksIndex].length; i++) {
                const [offsetX, offsetY] = kickTableToUse[currentKicksIndex][i];
                player.pos.x = originalPos.x + offsetX;
                player.pos.y = originalPos.y + offsetY;

                if (!collide(arena, player)) {
                    rotatedSuccessfully = true;
                    finalKickOffset = {x: offsetX, y: offsetY};
                    // Update rotation state based on successful rotation
                    if (isRight) {
                        player.rotState = (originalRotState + 1) % 4;
                    } else {
                        player.rotState = (originalRotState + 3) % 4; // (originalRotState - 1 + 4) % 4
                    }
                    break;
                }
            }

            if (rotatedSuccessfully) {
                player.isTSpin = checkTSpin(originalPos, player.pos, player.matrix, arena);
                // æ¥åœ°ä¸­ã«å›è»¢ã—ãŸã‚‰çŒ¶äºˆã‚’ãƒªã‚»ãƒƒãƒˆ
                if (player.isGrounded) {
                    lockDelayCounter = 0;
                    lockDelayMovesCounter++; // <--- ã“ã“ã§ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
                }
            } else {
                // Rotation failed, revert to original state
                player.matrix = clonedMatrix;
                player.pos = originalPos;
                player.rotState = originalRotState;
                player.isTSpin = false; // å›è»¢å¤±æ•—æ™‚ã¯T-Spinã§ã¯ãªã„
            }
        }


        function playerDrop() {
            if (isPaused) return false;

            player.pos.y++;
            if (collide(arena, player)) {
                player.pos.y--;
                // ã“ã“ã§åˆã‚ã¦æ¥åœ°ã—ãŸå ´åˆ
                if (!player.isGrounded) {
                    player.isGrounded = true;
                    lockDelayCounter = 0; // ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
                    lockDelayMovesCounter = 0; // æ“ä½œå›æ•°ãƒªã‚»ãƒƒãƒˆ
                }
                return true; // æ¥åœ°ã—ã¦ã„ã‚‹
            }
            player.isGrounded = false; // æ¥åœ°ã—ã¦ã„ãªã„
            lockDelayCounter = 0; // è½ä¸‹ä¸­ã¯ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
            lockDelayMovesCounter = 0; // è½ä¸‹ä¸­ã¯æ“ä½œå›æ•°ãƒªã‚»ãƒƒãƒˆ
            return false; // æ¥åœ°ã—ã¦ã„ãªã„
        }

        let softDropInterval = null;
        function startSoftDrop() {
            if (isPaused) return;
            if (!softDropInterval) {
                // ã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ãŒé–‹å§‹ã•ã‚ŒãŸã‚‰ã€æ¥åœ°çŒ¶äºˆã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ãƒªãƒªã‚»ãƒƒãƒˆã—ãªã„
                // æ¥åœ°çŒ¶äºˆã¯playerDrop()ãŒtrueã‚’è¿”ã—ãŸæ™‚ã«ã®ã¿æœ‰åŠ¹
                playerDrop(); // æœ€åˆã®1ãƒã‚¹è½ä¸‹
                softDropInterval = setInterval(() => {
                    const landed = playerDrop();
                    if (landed) {
                        // æ¥åœ°ã—ã¦ã„ã‚‹å ´åˆã¯è‡ªå‹•å›ºå®šã¯ã—ãªã„
                    }
                }, 50); // ã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ã®é€Ÿåº¦
            }
        }

        function stopSoftDrop() {
            clearInterval(softDropInterval);
            softDropInterval = null;
        }

        function hardDrop() {
            if (isPaused) return;

            while (!collide(arena, player)) {
                player.pos.y++;
            }
            player.pos.y--;
            merge(arena, player);
            const linesClearedThisDrop = arenaSweep();
            linesCleared += linesClearedThisDrop;
            calculateScore(linesClearedThisDrop);
            playerReset();
            canHold = true;
            dropCounter = 0;
            player.isTSpin = false;
        }

        function playerMove(dir) {
            if (isPaused) return false;

            const originalX = player.pos.x;
            player.pos.x += dir;
            if (collide(arena, player)) {
                player.pos.x = originalX; // æˆ»ã™
                return false;
            }
            // æ¥åœ°ä¸­ã«ç§»å‹•ã—ãŸã‚‰çŒ¶äºˆã‚’ãƒªã‚»ãƒƒãƒˆ
            if (player.isGrounded) {
                lockDelayCounter = 0;
                lockDelayMovesCounter++; // <--- ã“ã“ã§ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
            }
            return true;
        }

        const pieceShapes = {
            'T': [[0,1,0],[1,1,1],[0,0,0]],
            'O': [[1,1],[1,1]],
            'L': [[0,0,1],[1,1,1],[0,0,0]],
            'J': [[1,0,0],[1,1,1],[0,0,0]],
            'S': [[0,1,1],[1,1,0],[0,0,0]],
            'Z': [[1,1,0],[0,1,1],[0,0,0]],
            'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]]
        };

        function createPiece(type) {
            return pieceShapes[type].map(row => [...row]);
        }
        let nextPieceBag = [];
        function fillBag() {
            const types = 'TJLOSZI'.split('');
            for (let i = types.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [types[i], types[j]] = [types[j], types[i]];
            }
            nextPieceBag = types;
        }

        function getNextPieceType() {
            if (nextPieceBag.length === 0) {
                fillBag();
            }
            return nextPieceBag.shift();
        }

        function isArenaEmpty() {
            for (let y = 0; y < arena.length; y++) {
                for (let x = 0; x < arena[y].length; x++) {
                    if (arena[y][x] !== 0) {
                        return false;
                    }
                }
            }
            return true;
        }

        function arenaSweep() {
            let rowCount = 0;
            outer: for (let y = arena.length - 1; y >= 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) {
                    if (arena[y][x] === 0) {
                        continue outer;
                    }
                }
                const row = arena.splice(y, 1)[0].fill(0);
                arena.unshift(row);
                y++;
                rowCount++;
            }

            if (rowCount > 0) {
                combo++;
                if (combo > maxCombo) {
                    maxCombo = combo;
                }
            } else {
                combo = -1;
            }

            // Perfect Clearåˆ¤å®š
            // è¡ŒãŒå‰Šé™¤ã•ã‚Œã€ã‹ã¤ã‚¢ãƒªãƒ¼ãƒŠãŒå®Œå…¨ã«ç©ºã«ãªã£ãŸå ´åˆ
            if (rowCount > 0 && isArenaEmpty()) {
                perfectClearBonus = true;
            } else {
                perfectClearBonus = false;
            }

            return rowCount;
        }

        function calculateScore(lines) {
            let baseScore = 0;
            let comboBonus = 0;
            let tSpinBonus = 0;
            let difficultyMultiplier = 1;

            // é›£æ˜“åº¦ã«ã‚ˆã‚‹å€ç‡ã‚’èª¿æ•´
            if (currentDifficulty === 'easy') {
                difficultyMultiplier = 0.7; // ã¡ã‚‡ã£ã¨ä¸‹ã’ã‚‹
            } else if (currentDifficulty === 'normal') {
                difficultyMultiplier = 1.1; // ã¡ã‚‡ã£ã¨ä¸Šã’ã‚‹
            } else if (currentDifficulty === 'hard') {
                difficultyMultiplier = 1.5; // ã•ã‚‰ã«ä¸Šã’ã‚‹
            }

            if (player.isTSpin) {
                if (lines === 1) tSpinBonus = 800; // T-Spin Single
                else if (lines === 2) tSpinBonus = 1200; // T-Spin Double
                else if (lines === 3) tSpinBonus = 1600; // T-Spin Triple
            }
            player.isTSpin = false; // åˆ¤å®šå¾Œãƒªã‚»ãƒƒãƒˆ

            if (tSpinBonus === 0) { // T-Spinã§ã¯ãªã„å ´åˆ
                if (lines === 1) baseScore = 100;
                else if (lines === 2) baseScore = 300;
                else if (lines === 3) baseScore = 500;
                else if (lines === 4) baseScore = 800; // Tetris
            }

            if (combo > 0) {
                comboBonus = combo * 50;
            }

            let totalScore = (baseScore + comboBonus + tSpinBonus) * difficultyMultiplier;

            // Perfect Clearãƒœãƒ¼ãƒŠã‚¹ã‚’èª¿æ•´
            if (perfectClearBonus) {
                let pcBonus = 0;
                if (lines === 1) pcBonus = 1000; // PC Single
                else if (lines === 2) pcBonus = 1500; // PC Double
                else if (lines === 3) pcBonus = 2000; // PC Triple
                else if (lines === 4) pcBonus = 3000; // PC Tetris
                totalScore += pcBonus;
                console.log("Perfect Clear! Bonus: " + pcBonus);
            }

            score += Math.round(totalScore); // ã‚¹ã‚³ã‚¢ã¯æ•´æ•°ã«ä¸¸ã‚ã‚‹
            scoreElem.textContent = `ã‚¹ã‚³ã‚¢: ${score}`;
        }


        function getGhostPosition(player) {
            if (!player.matrix) return player.pos;

            const ghost = {
                pos: { x: player.pos.x, y: player.pos.y },
                matrix: player.matrix
            };
            let ghostY = player.pos.y;
            while (true) {
                ghost.pos.y = ghostY + 1;
                if (collide(arena, ghost)) {
                    ghost.pos.y = ghostY;
                    break;
                }
                ghostY++;
            }
            return ghost.pos;
        }

        function drawAll() {
            context.fillStyle = '#fff';
            context.fillRect(0, 0, canvas.width, canvas.height);

            arena.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        context.fillStyle = colors[value];
                        context.strokeStyle = colors['border'];
                        context.lineWidth = 0.03;
                        context.fillRect(x, y, 1, 1);
                        context.strokeRect(x, y, 1, 1);
                    }
                });
            });

            if (player.matrix && player.type) {
                const ghostPos = getGhostPosition(player);
                drawMatrix(player.matrix, ghostPos, context, 'ghost', 0.4);
                drawMatrix(player.matrix, player.pos, context, player.type);
            }

            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            for (let i = 0; i < nextPieces.length; i++) {
                const pieceType = nextPieces[i].type;
                const pieceMatrix = createPiece(pieceType);
                const xOffset = (nextCanvas.width / 20 / 2) - (pieceMatrix[0].length / 2);
                const yOffset = i * 4 + (4 - pieceMatrix.length) / 2;
                drawMatrix(pieceMatrix, {x: xOffset, y: yOffset}, nextCtx, pieceType);
            }

            holdCtx.clearRect(0, 0, holdCanvas.width, holdCanvas.height);
            if (hold.matrix && hold.type) {
                const xOffset = (holdCanvas.width / 20 / 2) - (hold.matrix[0].length / 2);
                const yOffset = (holdCanvas.height / 20 / 2) - (hold.matrix.length / 2);
                drawMatrix(hold.matrix, {x: xOffset, y: yOffset}, holdCtx, hold.type);
            }
        }

        let nextPieces = [];

        function playerReset() {
            player.type = nextPieces[0].type;
            player.matrix = createPiece(player.type);
            player.rotState = 0;

            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ³ã®èª¿æ•´: ãƒŸãƒã®åˆæœŸä½ç½®ã‚’Y=0ã‹ã‚‰é–‹å§‹
            player.pos.y = 0; 
            player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

            nextPieces.shift();
            nextPieces.push({type: getNextPieceType()});

            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š: æ–°ã—ã„ãƒ”ãƒ¼ã‚¹ãŒå‡ºç¾æ™‚ã«è¡çªã—ãŸã‚‰ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
            // ä¿®æ­£ï¼šåˆæœŸä½ç½®ã‚’y=2ã«ã—ã¦ã„ã‚‹ã®ã§ã€y=0ã§ã®è¡çªã§ã¯ãªãã€ãƒ”ãƒ¼ã‚¹ã®æœ€ä¸Šéƒ¨ãŒã‚¢ãƒªãƒ¼ãƒŠã®ä¸Šç«¯ã«è§¦ã‚Œã‚‹ã‹ã©ã†ã‹ã§åˆ¤æ–­
            // ã¤ã¾ã‚Šã€player.pos.yãŒ0ã‚ˆã‚Šä¸Šã«ã‚ã£ãŸã¨ã—ã¦ã‚‚ã€ãƒ”ãƒ¼ã‚¹è‡ªä½“ãŒã‚¢ãƒªãƒ¼ãƒŠã®æœ‰åŠ¹ç¯„å›²å¤–ã«ä½ç½®ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹
            if (collide(arena, player)) {
                cancelAnimationFrame(animationFrameId);
                arena.forEach(row => row.fill(0));

                player.matrix = null;
                player.type = null;

                stopSoftDrop();
                showGameOverModal(score, linesCleared);

                currentScoreAtGameOver = score;
                currentLinesClearedAtGameOver = linesCleared;
                currentMaxComboAtGameOver = maxCombo;

                score = 0;
                linesCleared = 0;
                combo = -1;
                maxCombo = 0;
                scoreElem.textContent = `ã‚¹ã‚³ã‚¢: ${score}`;
                hold.matrix = null;
                hold.type = null;
                hold.rotState = 0;
            }
            player.isGrounded = false; // æ–°ã—ã„ãƒ”ãƒ¼ã‚¹ãªã®ã§æ¥åœ°çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            lockDelayCounter = 0;
            lockDelayMovesCounter = 0;
        }

        function holdPiece() {
            if (isPaused) return;
            if (!canHold) return;

            const currentPieceType = player.type;
            const currentPieceMatrix = player.matrix.map(row => [...row]);
            const currentPieceRotState = player.rotState;

            let pieceToPlaceType;
            let pieceToPlaceMatrix;
            let pieceToPlaceRotState;

            if (!hold.matrix) {
                hold.type = currentPieceType;
                hold.matrix = currentPieceMatrix;
                hold.rotState = currentPieceRotState;

                playerReset();
            } else {
                pieceToPlaceType = hold.type;
                pieceToPlaceMatrix = hold.matrix.map(row => [...row]);
                pieceToPlaceRotState = hold.rotState;

                hold.type = currentPieceType;
                hold.matrix = currentPieceMatrix;
                hold.rotState = currentPieceRotState;

                player.type = pieceToPlaceType;
                player.matrix = pieceToPlaceMatrix;
                player.rotState = pieceToPlaceRotState;

                // ãƒ›ãƒ¼ãƒ«ãƒ‰å¾Œã®ãƒ”ãƒ¼ã‚¹ã®åˆæœŸä½ç½®ã‚‚y=2ã‹ã‚‰é–‹å§‹
                player.pos.y = 2; 
                player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

                if (collide(arena, player)) {
                    // ãƒ›ãƒ¼ãƒ«ãƒ‰ã—ãŸãƒ”ãƒ¼ã‚¹ãŒã™ãã«è¡çªã™ã‚‹å ´åˆã€å…ƒã®çŠ¶æ…‹ã«æˆ»ã™
                    player.type = currentPieceType;
                    player.matrix = currentPieceMatrix;
                    player.rotState = currentPieceRotState;
                    player.pos.y = 2; // åˆæœŸä½ç½®ã«æˆ»ã™
                    player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);

                    hold.type = pieceToPlaceType;
                    hold.matrix = pieceToPlaceMatrix;
                    hold.rotState = pieceToPlaceRotState;
                    return; // ãƒ›ãƒ¼ãƒ«ãƒ‰å¤±æ•—
                }
            }
            canHold = false;
            player.isTSpin = false;
            player.isGrounded = false; // ãƒ›ãƒ¼ãƒ«ãƒ‰ã—ãŸã‚‰æ¥åœ°çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            lockDelayCounter = 0;
            lockDelayMovesCounter = 0;
        }

        let dropCounter = 0;
        let dropInterval = 1000; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è½ä¸‹é–“éš”
        let lastTime = 0;
        let canHold = true;
        let animationFrameId;
        let isPaused = false;

        const arena = createMatrix(10, 20);
        const player = { pos: {x: 0, y: 0}, matrix: null, type: null, isTSpin: false, rotState: 0, isGrounded: false }; // isGroundedã‚’è¿½åŠ 
        const hold = { matrix: null, type: null, rotState: 0 };

        // æ¥åœ°çŒ¶äºˆã«é–¢ã™ã‚‹è¨­å®š
        const lockDelayTime = 500; // 500ãƒŸãƒªç§’ã®çŒ¶äºˆ
        const lockDelayMoves = 4; // æ¥åœ°ä¸­ã«è¨±å®¹ã•ã‚Œã‚‹æ“ä½œå›æ•°
        let lockDelayCounter = 0;
        let lockDelayMovesCounter = 0;

        function setDropIntervalByDifficulty(difficulty) {
            switch (difficulty) {
                case 'easy':
                    dropInterval = 1200; // é…ã„
                    break;
                case 'normal':
                    dropInterval = 600; // ãµã¤ã† (å°‘ã—é€Ÿã)
                    break;
                case 'hard':
                    dropInterval = 300; // ã‚€ãšã‹ã—ã„ (ã‹ãªã‚Šé€Ÿã)
                    break;
                default:
                    dropInterval = 800;
            }
            console.log(`é›£æ˜“åº¦: ${difficulty}, è½ä¸‹é–“éš”: ${dropInterval}ms`);
        }

        function initGame() {
            arena.forEach(row => row.fill(0));
            score = 0;
            linesCleared = 0;
            combo = -1;
            maxCombo = 0;
            player.isTSpin = false;
            player.rotState = 0;
            perfectClearBonus = false;

            scoreElem.textContent = `ã‚¹ã‚³ã‚¢: ${score}`;
            hold.matrix = null;
            hold.type = null;
            hold.rotState = 0;
            nextPieces = [];
            fillBag();

            for(let i = 0; i < 3; i++) {
                nextPieces.push({type: getNextPieceType()});
            }

            // initGameã§ã‚‚playerResetã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«å¤‰æ›´
            playerReset(); // ã“ã‚Œã«ã‚ˆã‚Šã€åˆæœŸãƒ”ãƒ¼ã‚¹ãŒy=2ã‹ã‚‰å‡ºç¾ã™ã‚‹

            canHold = true;
            dropCounter = 0;
            lastTime = 0;

            stopSoftDrop();
            
            // æ¥åœ°çŒ¶äºˆé–¢é€£ã®å¤‰æ•°ã‚’åˆæœŸåŒ–
            player.isGrounded = false;
            lockDelayCounter = 0;
            lockDelayMovesCounter = 0;

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            isPaused = false;
            pauseButton.style.display = 'block';
            animationFrameId = requestAnimationFrame(update);
        }

        function update(time = 0) {
            if (isPaused) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            const deltaTime = time - lastTime;
            lastTime = time;

            // é€šå¸¸ã®è‡ªå‹•è½ä¸‹
            if (!softDropInterval) {
                dropCounter += deltaTime;
                if (dropCounter > dropInterval) {
                    const landed = playerDrop(); // è½ä¸‹ã‚’è©¦ã¿ã‚‹

                    // æ¥åœ°çŒ¶äºˆã®å‡¦ç†
                    if (landed) { // æ¥åœ°ã—ã¦ã„ã‚‹å ´åˆ
                        lockDelayCounter += deltaTime;
                        // çŒ¶äºˆæ™‚é–“è¶…éã€ã¾ãŸã¯æ“ä½œå›æ•°åˆ¶é™ã‚’è¶…ãˆãŸã‚‰å›ºå®š
                        if (lockDelayCounter >= lockDelayTime || lockDelayMovesCounter >= lockDelayMoves) {
                            merge(arena, player);
                            const linesClearedThisDrop = arenaSweep();
                            linesCleared += linesClearedThisDrop;
                            calculateScore(linesClearedThisDrop);
                            playerReset();
                            canHold = true;
                            player.isTSpin = false; // æ¬¡ã®ãƒ”ãƒ¼ã‚¹ã§ã¯T-Spinã§ã¯ãªã„
                        }
                    } else { // è½ä¸‹ä¸­ã®å ´åˆ
                        dropCounter %= dropInterval; // è½ä¸‹ã—ãªã„é™ã‚Šã‚¿ã‚¤ãƒãƒ¼ã¯ãƒªã‚»ãƒƒãƒˆ
                        player.isGrounded = false; // è½ä¸‹ã—ã¦ã„ã‚‹ã®ã§æ¥åœ°ã§ã¯ãªã„
                        lockDelayCounter = 0; // çŒ¶äºˆã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
                        lockDelayMovesCounter = 0; // æ“ä½œå›æ•°ãƒªã‚»ãƒƒãƒˆ
                    }
                }
            } else {
                // ã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ä¸­ã¯playerDrop()ãŒåˆ¥é€”å‘¼ã°ã‚Œã¦ã„ã‚‹ãŸã‚ã€
                // æ¥åœ°çŒ¶äºˆã®å›ºå®šãƒ­ã‚¸ãƒƒã‚¯ã¯ã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ—å†…ã§ç®¡ç†ã—ãªã„
                // ï¼ˆé€£ç¶šè½ä¸‹ã®ãŸã‚ï¼‰
            }

            drawAll();

            animationFrameId = requestAnimationFrame(update);
        }

        // --- ä¸€æ™‚åœæ­¢æ©Ÿèƒ½ ---
        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                cancelAnimationFrame(animationFrameId);
                stopSoftDrop();
                pauseOverlay.style.display = 'flex';
                pauseButton.style.display = 'none';
            } else {
                pauseOverlay.style.display = 'none';
                pauseButton.style.display = 'block';
                animationFrameId = requestAnimationFrame(update);
            }
        }

        function resumeGame() {
            togglePause();
        }

        function endGame() {
            const confirmEnd = confirm("ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã—ã¦ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿç¾åœ¨ã®ã‚¹ã‚³ã‚¢ã¯ä¿å­˜ã•ã‚Œã¾ã›ã‚“ã€‚");
            if (confirmEnd) {
                hideGameOverModalAndShowMenu();
                score = 0;
                linesCleared = 0;
                combo = -1;
                maxCombo = 0;
                scoreElem.textContent = `ã‚¹ã‚³ã‚¢: ${score}`;
                hold.matrix = null;
                hold.type = null;
                hold.rotState = 0;
                nextPieces = [];
                isPaused = false;
                pauseButton.style.display = 'none';
                pauseOverlay.style.display = 'none';
            }
        }



        // --- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«é–¢é€£ ---
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const finalScoreDisplay = document.getElementById('final-score-display');
        const linesClearedDisplay = document.getElementById('lines-cleared-display');
        const maxComboDisplay = document.getElementById('max-combo-display');

        let currentScoreAtGameOver = 0;
        let currentLinesClearedAtGameOver = 0;
        let currentMaxComboAtGameOver = 0;

        function showGameOverModal(finalScore, finalLinesCleared) {
            currentScoreAtGameOver = finalScore;
            currentLinesClearedAtGameOver = finalLinesCleared;
            currentMaxComboAtGameOver = maxCombo;

            finalScoreDisplay.textContent = `ã‚¹ã‚³ã‚¢: ${finalScore}`;
            linesClearedDisplay.textContent = `æ¶ˆã—ãŸãƒ©ã‚¤ãƒ³æ•°: ${finalLinesCleared}`;
            maxComboDisplay.textContent = `æœ€å¤§é€£é–æ•°: ${currentMaxComboAtGameOver}`;
            gameOverOverlay.style.display = 'flex';
            pauseButton.style.display = 'none';
        }

        function hideGameOverModalAndShowMenu() {
            gameOverOverlay.style.display = 'none';
            pauseOverlay.style.display = 'none';
            showModeSelection(); // ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹
        }


        // --- UIè¦ç´ ã®å–å¾— ---
        const overlay = document.getElementById('overlay');
        const modeSelectionModal = document.getElementById('mode-selection-modal');
        const btnModeButton = document.getElementById('btn-mode-button');
        const btnModeGesture = document.getElementById('btn-mode-gesture');
        const btnShowRankingFromMain = document.getElementById('btn-show-ranking-from-main');

        const difficultySelectionOverlay = document.getElementById('difficulty-selection-overlay');
        const difficultySelectionModal = document.getElementById('difficulty-selection-modal');
        const btnDifficultyEasy = document.getElementById('btn-difficulty-easy');
        const btnDifficultyNormal = document.getElementById('btn-difficulty-normal');
        const btnDifficultyHard = document.getElementById('btn-difficulty-hard');
        const btnBackToModeSelection = document.getElementById('btn-back-to-mode-selection');

        const uiButtons = document.getElementById('ui');
        const tetrisCanvas = document.getElementById('tetris');
        const holdArea = document.getElementById('hold');


        // --- ç”»é¢è¡¨ç¤ºåˆ¶å¾¡é–¢æ•° ---
        function showModeSelection() {
            overlay.style.display = 'flex';
            modeSelectionModal.style.display = 'block';
            difficultySelectionOverlay.style.display = 'none';
            rankingOverlay.style.display = 'none';
            gameOverOverlay.style.display = 'none';
            pauseOverlay.style.display = 'none';
            uiButtons.style.display = 'none'; // ã‚²ãƒ¼ãƒ ä¸­ã®ãƒœã‚¿ãƒ³UIã‚’éè¡¨ç¤º
            pauseButton.style.display = 'none'; // ãƒãƒ¼ã‚ºãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
            detachControlEventListeners(); // ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡¨ç¤ºä¸­ã¯ã‚²ãƒ¼ãƒ æ“ä½œãƒªã‚¹ãƒŠãƒ¼ã‚’ç„¡åŠ¹åŒ–
        }

        function showDifficultySelection() {
            overlay.style.display = 'none'; // æ“ä½œãƒ¢ãƒ¼ãƒ‰é¸æŠã‚’éè¡¨ç¤º
            difficultySelectionOverlay.style.display = 'flex'; // é›£æ˜“åº¦é¸æŠã‚’è¡¨ç¤º
        }

        function startGame() {
            difficultySelectionOverlay.style.display = 'none'; // é›£æ˜“åº¦é¸æŠã‚’éè¡¨ç¤º
            overlay.style.display = 'none'; // ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚‚éè¡¨ç¤º
            
            // ä¿®æ­£: ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã‚‚å¸¸ã«ãƒœã‚¿ãƒ³UIã‚’è¡¨ç¤º
            uiButtons.style.display = 'grid'; 
            
            initGame(); // ã‚²ãƒ¼ãƒ é–‹å§‹
        }

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š ---
        btnModeButton.addEventListener('click', () => {
            currentControlMode = 'button';
            showDifficultySelection();
        });

        btnModeGesture.addEventListener('click', () => {
            currentControlMode = 'gesture';
            showDifficultySelection();
        });



        btnDifficultyEasy.addEventListener('click', () => {
            currentDifficulty = 'easy';
            setDropIntervalByDifficulty(currentDifficulty);
            startGame();
        });

        btnDifficultyNormal.addEventListener('click', () => {
            currentDifficulty = 'normal';
            setDropIntervalByDifficulty(currentDifficulty);
            startGame();
        });

        btnDifficultyHard.addEventListener('click', () => {
            currentDifficulty = 'hard';
            setDropIntervalByDifficulty(currentDifficulty);
            startGame();
        });

        btnBackToModeSelection.addEventListener('click', showModeSelection);


        // --- ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ ---
        function handleKeyboardInput(event) {
            if (isPaused && event.key !== 'p' && event.key !== 'P' && event.key !== 'Escape') return;
            if (event.key === 'ArrowLeft') playerMove(-1);
            else if (event.key === 'ArrowRight') playerMove(1);
            else if (event.key === 'ArrowDown') startSoftDrop();
            else if (event.key === 'ArrowUp') hardDrop();
            else if (event.key === 'c' || event.key === 'C') holdPiece();
            else if (event.key === 'z' || event.key === 'Z') playerRotate(false);
            else if (event.key === 'x' || event.key === 'X') playerRotate(true);
            else if (event.key === 'p' || event.key === 'P' || event.key === 'Escape') togglePause();
        }

        function handleKeyboardInputUp(event) {
            if (event.key === 'ArrowDown') {
                stopSoftDrop();
            }
        }

        // --- ã‚¿ãƒƒãƒã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼é–¢é€£ ---
        let startX = 0;
        let startY = 0;
        let lastMoveTime = 0;
        const moveDebounceTime = 100;
        let lastProcessedTouchX = 0;
        let lastProcessedTouchY = 0;

        const lateralMoveThreshold = 30;
        const hardDropSwipeThreshold = 50;
        const softDropSwipeThreshold = 30;
        const rotationTapThreshold = 10;


        function handleTouchStart(event) {
            if (currentControlMode !== 'gesture' || isPaused) return;

            event.preventDefault(); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢
            startX = event.touches[0].clientX;
            startY = event.touches[0].clientY;
            lastProcessedTouchX = startX;
            lastProcessedTouchY = startY;

            stopSoftDrop();
        }

        function handleTouchMove(event) {
            if (currentControlMode !== 'gesture' || isPaused) return;

            event.preventDefault(); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢
            const currentTime = Date.now();
            const currentX = event.touches[0].clientX;
            const currentY = event.touches[0].clientY;

            const deltaXSinceStart = currentX - startX;
            const deltaYSinceStart = currentY - startY;

            // æ¨ªç§»å‹•ã®å‡¦ç†ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ã‚’é©ç”¨ï¼‰
            if (currentTime - lastMoveTime > moveDebounceTime) {
                const diffX = currentX - lastProcessedTouchX;
                if (Math.abs(diffX) > lateralMoveThreshold / 2) {
                    const dir = (diffX > 0) ? 1 : -1;
                    if (playerMove(dir)) {
                        lastProcessedTouchX = currentX;
                        lastMoveTime = currentTime;
                    }
                }
            }

            // ã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ã®é–‹å§‹
            // ä¸‹æ–¹å‘ã¸ã®ã‚ã‚‹ç¨‹åº¦ã®ç§»å‹•ã§ã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ—é–‹å§‹
            if (deltaYSinceStart > softDropSwipeThreshold && Math.abs(deltaYSinceStart) > Math.abs(deltaXSinceStart)) {
                startSoftDrop();
            } else if (deltaYSinceStart <= 0 && softDropInterval) { // ä¸Šæ–¹å‘ã¸ã®ç§»å‹•ã‚„æ¨ªæ–¹å‘ã®ç§»å‹•ãŒå¤§ãããªã£ãŸå ´åˆã«ã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ã‚’åœæ­¢
                stopSoftDrop();
            }
        }

        function handleTouchEnd(event) {
            if (currentControlMode !== 'gesture' || isPaused) return;

            stopSoftDrop(); // æŒ‡ã‚’é›¢ã—ãŸã‚‰ã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ã‚’åœæ­¢

            const endX = event.changedTouches[0].clientX;
            const endY = event.changedTouches[0].clientY;

            const deltaX = endX - startX;
            const deltaY = endY - startY;

            // ä¸Šæ–¹å‘ã¸ã®ã‚¹ãƒ¯ã‚¤ãƒ—ã§ãƒãƒ¼ãƒ‰ãƒ‰ãƒ­ãƒƒãƒ—
            if (deltaY < -hardDropSwipeThreshold && Math.abs(deltaY) > Math.abs(deltaX)) {
                hardDrop();
            }
            // çŸ­ã„ã‚¿ãƒƒãƒ—ã§å›è»¢ (ç§»å‹•é‡ãŒå°ã•ã„å ´åˆ)
            else if (Math.abs(deltaX) < rotationTapThreshold && Math.abs(deltaY) < rotationTapThreshold) {
                const rect = tetrisCanvas.getBoundingClientRect();
                const touchX = endX - rect.left;

                if (touchX < rect.width / 2) {
                    playerRotate(false); // å·¦åŠåˆ†ã‚’ã‚¿ãƒƒãƒ—ã§å·¦å›è»¢
                } else {
                    playerRotate(true); // å³åŠåˆ†ã‚’ã‚¿ãƒƒãƒ—ã§å³å›è»¢
                }
            }
        }

        function handleHoldTouch(event) {
            if (currentControlMode !== 'gesture' || isPaused) return;
            event.preventDefault();
            holdPiece();
        }
        
        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®ç™»éŒ²ã¨è§£é™¤ã‚’ç®¡ç†ã™ã‚‹é–¢æ•° ---
        function attachControlEventListeners() {
            document.addEventListener('keydown', handleKeyboardInput);
            document.addEventListener('keyup', handleKeyboardInputUp);

            // ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã®ã¿ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ç™»éŒ²
            if (currentControlMode === 'gesture') {
                tetrisCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                tetrisCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                tetrisCanvas.addEventListener('touchend', handleTouchEnd);
                holdArea.addEventListener('touchstart', handleHoldTouch, { passive: false }); // HOLDãƒœã‚¿ãƒ³ã‚‚ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã‚’æœ‰åŠ¹ã«
            }
        }

        function detachControlEventListeners() {
            document.removeEventListener('keydown', handleKeyboardInput);
            document.removeEventListener('keyup', handleKeyboardInputUp);

            tetrisCanvas.removeEventListener('touchstart', handleTouchStart);
            tetrisCanvas.removeEventListener('touchmove', handleTouchMove);
            tetrisCanvas.removeEventListener('touchend', handleTouchEnd);
            holdArea.removeEventListener('touchstart', handleHoldTouch);
        }
        function endGame() {
            const confirmEnd = confirm("ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã—ã¦ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿç¾åœ¨ã®ã‚¹ã‚³ã‚¢ã¯ä¿å­˜ã•ã‚Œã¾ã›ã‚“ã€‚");
            if (confirmEnd) {
                hideGameOverModalAndShowMenu();
                score = 0;
                linesCleared = 0;
                combo = -1;
                maxCombo = 0;
                scoreElem.textContent = `ã‚¹ã‚³ã‚¢: ${score}`;
                hold.matrix = null;
                hold.type = null;
                hold.rotState = 0;
                nextPieces = [];
                isPaused = false;
                pauseButton.style.display = 'none';
                pauseOverlay.style.display = 'none';
            }
        }

        // `initGame`ã®å¤‰æ›´: ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å†ç™»éŒ²ã™ã‚‹
        const originalInitGame = initGame;
        initGame = () => {
            // ã‚²ãƒ¼ãƒ é–‹å§‹å‰ã«æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å…¨ã¦è§£é™¤
            detachControlEventListeners(); 
            // å…ƒã®åˆæœŸåŒ–å‡¦ç†
            originalInitGame(); 
            // æ–°ã—ã„ï¼ˆé¸æŠã•ã‚ŒãŸãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ãŸï¼‰ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ç™»éŒ²
            attachControlEventListeners(); 
        };

        // åˆæœŸè¡¨ç¤ºã¯ãƒ¢ãƒ¼ãƒ‰é¸æŠç”»é¢
        showModeSelection();
    </script>
</body>
</html>
